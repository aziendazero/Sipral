package com.phi.odt;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.io.StringWriter;
import java.nio.charset.Charset;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.faces.application.FacesMessage;
import javax.imageio.ImageIO;
import javax.ws.rs.HeaderParam;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import net.sf.jooreports.templates.DocumentTemplate;
import net.sf.jooreports.templates.DocumentTemplateFactory;
import net.sf.jooreports.templates.image.ImageSource;
import net.sf.jooreports.templates.image.RenderedImageSource;

import org.apache.commons.codec.Charsets;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.SerializationUtils;
import org.apache.commons.lang.WordUtils;
import org.apache.log4j.Logger;
import org.hibernate.Criteria;
import org.hibernate.criterion.Restrictions;
import org.hibernate.proxy.HibernateProxy;
import org.jboss.seam.Component;
import org.jboss.seam.ScopeType;
import org.jboss.seam.annotations.Name;
import org.jboss.seam.annotations.Scope;
import org.jboss.seam.annotations.intercept.BypassInterceptors;
import org.jboss.seam.contexts.Context;
import org.jboss.seam.contexts.Contexts;
import org.jboss.seam.faces.FacesMessages;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.phi.cs.CatalogPersistenceManagerImpl;
import com.phi.cs.catalog.adapter.CatalogAdapter;
import com.phi.cs.datamodel.IdataModel;
import com.phi.cs.datamodel.PagedDataModel;
import com.phi.cs.datamodel.PhiDataModel;
import com.phi.cs.error.ErrorConstants;
import com.phi.cs.error.FacesErrorUtils;
import com.phi.cs.exception.PhiException;
import com.phi.entities.actions.BaseAction;
import com.phi.entities.baseEntity.BaseEntity;
import com.phi.entities.role.ServiceDeliveryLocation;
import com.phi.security.UserBean;

import freemarker.core.InvalidReferenceException;

@BypassInterceptors
@Name("OdtEngine")
@Scope(ScopeType.CONVERSATION)
public class OdtEngine implements Serializable {

	private static final long serialVersionUID = -4730204170363980943L;
	private static final Logger log = Logger.getLogger(OdtEngine.class);
	
	private static final String headerPrefix = "HF_";
	private static final String TAG_OFFICEDOCUMENTSTYLES = "office:document-styles";
	private static final String TAG_OFFICEFONTFACEDECLS = "office:font-face-decls";
	
	public static OdtEngine instance() {
		return (OdtEngine) Component.getInstance(OdtEngine.class, ScopeType.CONVERSATION);
	}
	
	public byte[] generateFromTemplate(byte[] templateBytes) throws PhiException {
		return generateFromTemplate(templateBytes, null);
	}
	
	/**
	 * Generate report from template
	 * @param templateBytes odt of template
	 * @param sdlCode code of enabled sdl to find logo, header footer...
	 * @return report generated by filling variables with conversation data 
	 * @throws Exception 
	 */
	public byte[] generateFromTemplate(byte[] templateBytes, String sdlCode) throws PhiException {
		
		try {

			ByteArrayInputStream odtIs = new ByteArrayInputStream(templateBytes); 

			ByteArrayOutputStream odtOs = new ByteArrayOutputStream();

			DocumentTemplateFactory documentTemplateFactory = new DocumentTemplateFactory();
			//TODO: prova: documentTemplateFactory.getFreemarkerConfiguration().setClassicCompatible(true); 
			//documentTemplateFactory.getFreemarkerConfiguration().setClassicCompatible(true); 
			
			//questo rimuove *TUTTE* le eccezioni di freemarker.  
			//documentTemplateFactory.getFreemarkerConfiguration().setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER);
			
			// custom template error handler
			//documentTemplateFactory.getFreemarkerConfiguration().setTemplateExceptionHandler(new PhiTemplateExceptionHandler());
			
			
			DocumentTemplate template = documentTemplateFactory.getTemplate(odtIs); 

			template.createDocument(getModel(sdlCode), odtOs);
				
			return odtOs.toByteArray();
			
		} catch (Exception e) {
			String instructionStack = "";
			if (e.getCause() != null && e.getCause() instanceof InvalidReferenceException) {
				instructionStack = ((InvalidReferenceException)e.getCause()).getFTLInstructionStack();
			}
			FacesMessages.instance().add(FacesMessage.SEVERITY_ERROR, e.getMessage());
			//FacesErrorUtils.addErrorMessage(ErrorConstants.WEB_SERVICE_ERR_CODE,e.getMessage());
			if (!"".isEmpty()) {
				throw new PhiException("Error generating report " + e.getMessage() + "\r\n" + instructionStack, e, ErrorConstants.GENERIC_ERR_CODE);
			}
			return null;
			//throw new PhiException("Error generating report " + e.getMessage() + "\r\n" + instructionStack, e, ErrorConstants.GENERIC_ERR_CODE);
		}
	}
	
	/**
	 * Generate freemarker model from conversation, see: http://freemarker.org/
	 * @param sdlCode code of enabled sdl, added to model as Sdl.
	 * @return Map of objects in conversation
	*/
	@SuppressWarnings("rawtypes")
	protected Map<String, Object> getModel(String sdlCode) {
		Map<String, Object> model = new HashMap<String, Object>();
		
		//Date
		model.put("currentDate", new Date());
		
		//ServiceDeliveryLocation
		if (sdlCode != null) {
			List<Long> sdlocIds = UserBean.instance().getSdLocs();
			CatalogAdapter ca = CatalogPersistenceManagerImpl.instance(); 
			
			if (sdlocIds != null && !sdlocIds.isEmpty()) {

				Criteria sdlCrit = ca.createCriteria(ServiceDeliveryLocation.class)
						.add(Restrictions.in("internalId", sdlocIds))
						.createCriteria("code")
						.add(Restrictions.eq("code", sdlCode));
				
				@SuppressWarnings("unchecked")
				List<ServiceDeliveryLocation> sdlList = sdlCrit.list();
	
				ServiceDeliveryLocation sdl = null;
				
				if (sdlList.size() == 1) {
					sdl = sdlList.get(0);
				} else if (sdlList.size() > 1) {
					log.warn("Multiple ULSS selected at login, selected sdl: " + sdlList + " using first one");
					sdl = sdlList.get(0);
				} else {
					log.warn("No SDL selected at login, freemarker model must not contain reference to SDL");
					//throw new IllegalArgumentException("No ULSS selected at login, unable to generate header");
				}
				
				String sdlName = WordUtils.capitalize(sdlCode.toLowerCase());
				model.put(sdlName, sdl);
				
				//Logo
				if (sdl != null && sdl.getLogo() != null) {
					try {
						ImageSource headeriImg = new RenderedImageSource(ImageIO.read(new ByteArrayInputStream(sdl.getLogo())));
						model.put("currentHeader", headeriImg);
					} catch (IOException e) {
						log.error("Error loading header image " + e.getMessage(), e);
					}
				} else {
					log.warn("ServiceDeliveryLocation " + sdl.getName() + " has no logo!");
				}
	
			} else {
				log.warn("No SDL selected at login, freemarker model must not contain reference to SDL");
				//throw new IllegalArgumentException("No ServiceDeliveryLocation selected at login, unable to generate header");
			}
		}
		
		if (model.get("currentHeader") == null) {
			//Set default header to prevent error in generating reports with currentHeader : 
			//freemarker.template.TemplateModelException: No signature of method image matches the arguments
            BufferedImage img = new BufferedImage(16,16, BufferedImage.TYPE_INT_RGB );

			ImageSource headeriImg = new RenderedImageSource(img);
			model.put("currentHeader", headeriImg);
		}
		
		//Conversation
		Context currentConv = Contexts.getConversationContext();
		String[] names = currentConv.getNames();
		Object object = null;
		for(String name:names) {
			object = currentConv.get(name);
			if (object instanceof BaseEntity || object instanceof IdataModel || object instanceof BaseAction){
				if (object instanceof PagedDataModel) {
					model.put(name, ((PagedDataModel) object).getFullList());
					
				} else if(object instanceof PhiDataModel){
					model.put(name, ((PhiDataModel) object).getList());
					
				} else {
					if (object instanceof HibernateProxy) {
						if(!((HibernateProxy)object).getHibernateLazyInitializer().isUninitialized()) { //if is initialized, get the object
							object = ((HibernateProxy)object).getHibernateLazyInitializer().getImplementation();
						}
					}
					model.put(name, object);
				}
			}
		}
		
		return model;
	}
	
	
	private final Pattern freeMarkerVariablePattern = Pattern.compile("\\$\\{([^\\}]*)\\}");
	private final Pattern freeMarkerCodePattern = Pattern.compile("(\\[/?#[^\\]]*\\])");
	
	/**
	 * Fix odt template
	 * removes all styles from inside freemarker variables ${ ... } and freemarker code blocks [# ... ]
	 * 
	 * @param modelBarr byte array containing odt file of model to fix
	 * @throws PhiException 
	 */
	public byte[] fixModel(byte[] modelBarr) throws Exception {
		ZipInputStream modelZis = null;
		ZipOutputStream newModelZos = null;
		ByteArrayOutputStream newModelBaos = null;
		
		try {
			
			modelZis = new ZipInputStream(new ByteArrayInputStream(modelBarr));
			ZipEntry modelZe = modelZis.getNextEntry();
			
			StringBuffer newContent = new StringBuffer();
			
			while(modelZe != null) {
				if ("content.xml".equals(modelZe.getName())) {
					String content = IOUtils.toString(modelZis, "UTF-8"); 
					
					Matcher matcherv = freeMarkerVariablePattern.matcher(content);
					while (matcherv.find()) {
						String variable = matcherv.group(1);
						String fixedVariable = variable.replaceAll("<[^>]*>", ""); //Remove xml inside variables ${ ... }
						if (!variable.equals(fixedVariable)) {
							log.warn("Fixing template variable from: ${" + variable + "} to ${" + fixedVariable + "}");
						}
						matcherv.appendReplacement(newContent, "\\$\\{" + fixedVariable + "\\}");
					}
					matcherv.appendTail(newContent);
					
					Matcher matcherc = freeMarkerCodePattern.matcher(newContent.toString());
					newContent = new StringBuffer();
					while (matcherc.find()) {
						String code = matcherc.group(1);
						String fixedCode = code.replaceAll("<[^>]*>", ""); //Remove xml inside code blocks [# ... ]
						if (!code.equals(fixedCode)) {
							log.warn("Fixing template code block from: " + code + " to " + fixedCode);
						}
						matcherc.appendReplacement(newContent, fixedCode);
					}
					matcherc.appendTail(newContent);
					break;
				}
				modelZis.closeEntry();
				modelZe = modelZis.getNextEntry();
			}
			
			//model
			modelZis.close();
			modelZis = new ZipInputStream(new ByteArrayInputStream(modelBarr));
			ZipEntry documentZe = modelZis.getNextEntry();
			
			//new model
			newModelBaos = new ByteArrayOutputStream();
			newModelZos = new ZipOutputStream(newModelBaos);
			
			byte[] buf = new byte[4096];
			
			while(documentZe!=null){
				newModelZos.putNextEntry(new ZipEntry(documentZe.getName()));
				if ("content.xml".equals(documentZe.getName())) {
					newModelZos.write(newContent.toString().getBytes("UTF-8"));
				} else {
					//IOUtils.copy(documentZis, newDocumentZos); 
		            int len;
		            while ((len = modelZis.read(buf)) > 0) {
		            	newModelZos.write(buf, 0, len);
		            }
				}
				newModelZos.closeEntry();

				modelZis.closeEntry();
			   documentZe = modelZis.getNextEntry();
			}
			newModelZos.close();
			newModelBaos.close();
			byte[] newModelBarr = newModelBaos.toByteArray();
			
			return newModelBarr;
			
		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (modelZis != null) {
					modelZis.close();
				}				
				if (newModelZos != null) {
					newModelZos.close();
				}
				if (newModelBaos != null) {
					newModelBaos.close();
				}
			} catch (IOException e) {
				throw e;
			}
		}
	}
	
	/**
	 * Replaces styles.xml inside document.odt with styles.xml of model.odt
	 * 
	 * see: http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html
	 * 
	 * @param modelNodeRef alfresco id of model that contains header and footer
	 * @throws PhiException 
	 */	
	public byte[] applyModelToDocument(byte[] modelBarr, byte[] documentBarr) throws Exception  {
		
		ZipInputStream modelZis = null;
		ZipInputStream documentZis = null;
		ZipOutputStream newDocumentZos = null;
		ByteArrayOutputStream newDocumentBaos = null;
		
		try {
			
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();

			modelZis = new ZipInputStream(new ByteArrayInputStream(modelBarr), Charset.forName("UTF-8"));
			ZipEntry modelZe = modelZis.getNextEntry();

			byte[] styles = null;
			Document model = null;
			Document document;
//			Map<String, byte[]> pictures = new HashMap<String, byte[]>();
			
			while(modelZe!=null){
			   if ("styles.xml".equals(modelZe.getName())) {
				   model = docBuilder.parse(modelZis);
				   break;
//			   } else if (modelZe.getName().startsWith("Pictures")) {
//				   pictures.put(modelZe.getName(), IOUtils.toByteArray(modelZis));
			   }
			   modelZis.closeEntry();
			   modelZe = modelZis.getNextEntry();
			}

			//document
			//byte[] documentBarr = alfrescoGet(getEntity().getNodeRefUrl());
			documentZis = new ZipInputStream(new ByteArrayInputStream(documentBarr), Charset.forName("UTF-8"));
			ZipEntry documentZe = documentZis.getNextEntry();
			
			//new document
			newDocumentBaos = new ByteArrayOutputStream();
			newDocumentZos = new ZipOutputStream(newDocumentBaos);
			
			byte[] buf = new byte[4096];
			
			while(documentZe!=null){
				newDocumentZos.putNextEntry(new ZipEntry(documentZe.getName()));
				if ("styles.xml".equals(documentZe.getName())) {
					document = docBuilder.parse(new UncloseableInputStream(documentZis));
					styles = replaceHeaderFooter(model, document);
					newDocumentZos.write(styles);
				} else {
					//IOUtils.copy(documentZis, newDocumentZos); 
		            int len;
		            while ((len = documentZis.read(buf)) > 0) {
		            	newDocumentZos.write(buf, 0, len);
		            }
				}
				newDocumentZos.closeEntry();

			   documentZis.closeEntry();
			   documentZe = documentZis.getNextEntry();
			}
			
//			for (String pictureName : pictures.keySet()) {
//				newDocumentZos.putNextEntry(new ZipEntry(pictureName));
//				newDocumentZos.write(pictures.get(pictureName));
//				newDocumentZos.closeEntry();
//			}
			
			newDocumentZos.close();
			newDocumentBaos.close();
			byte[] newDocumentBarr = newDocumentBaos.toByteArray();
			
			return newDocumentBarr;
			
			
		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (modelZis != null) {
					modelZis.close();
				}
				if (documentZis != null) {
					documentZis.close();
				}
				if (newDocumentZos != null) {
					newDocumentZos.close();
				}
				if (newDocumentBaos != null) {
					newDocumentBaos.close();
				}
			} catch (IOException e) {
				throw e;
			}
		}
	}
	

	/**
		 * Replaces styles.xml inside document.odt with styles.xml of model.odt
		 * 
		 * see: http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html
		 * 
		 * @param modelNodeRef alfresco id of model that contains header and footer
		 * @throws PhiException 
		 */	
		public byte[] applyModelFirstPageToDocument(byte[] modelBarr, byte[] documentBarr) throws Exception  {
			
			ZipInputStream modelZis = null;
			ZipInputStream documentZis = null;
			ZipOutputStream newDocumentZos = null;
			ByteArrayOutputStream newDocumentBaos = null;
			
			try {
				
				DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
				DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
	
				modelZis = new ZipInputStream(new ByteArrayInputStream(modelBarr));
				ZipEntry modelZe = modelZis.getNextEntry();
	
				byte[] styles = null;
				Document model = null;
				Document document;
	//			Map<String, byte[]> pictures = new HashMap<String, byte[]>();
				
				while(modelZe!=null){
				   if ("styles.xml".equals(modelZe.getName())) {
					   model = docBuilder.parse(modelZis);
					   break;
	//			   } else if (modelZe.getName().startsWith("Pictures")) {
	//				   pictures.put(modelZe.getName(), IOUtils.toByteArray(modelZis));
				   }
				   modelZis.closeEntry();
				   modelZe = modelZis.getNextEntry();
				}
	
				//document
				//byte[] documentBarr = alfrescoGet(getEntity().getNodeRefUrl());
				documentZis = new ZipInputStream(new ByteArrayInputStream(documentBarr));
				ZipEntry documentZe = documentZis.getNextEntry();
				
				//new document
				newDocumentBaos = new ByteArrayOutputStream();
				newDocumentZos = new ZipOutputStream(newDocumentBaos);
				
				byte[] buf = new byte[4096];
				
				while(documentZe!=null){
					newDocumentZos.putNextEntry(new ZipEntry(documentZe.getName()));
					if ("styles.xml".equals(documentZe.getName())) {
						document = docBuilder.parse(new UncloseableInputStream(documentZis));
						styles = replaceFirstPageHeader(model, document);
						newDocumentZos.write(styles);
					} else {
						//IOUtils.copy(documentZis, newDocumentZos); 
			            int len;
			            while ((len = documentZis.read(buf)) > 0) {
			            	newDocumentZos.write(buf, 0, len);
			            }
					}
					newDocumentZos.closeEntry();
	
				   documentZis.closeEntry();
				   documentZe = documentZis.getNextEntry();
				}
				
	//			for (String pictureName : pictures.keySet()) {
	//				newDocumentZos.putNextEntry(new ZipEntry(pictureName));
	//				newDocumentZos.write(pictures.get(pictureName));
	//				newDocumentZos.closeEntry();
	//			}
				
				newDocumentZos.close();
				newDocumentBaos.close();
				byte[] newDocumentBarr = newDocumentBaos.toByteArray();
				
				return newDocumentBarr;
				
				
			} catch (Exception e) {
				throw e;
			} finally {
				try {
					if (modelZis != null) {
						modelZis.close();
					}
					if (documentZis != null) {
						documentZis.close();
					}
					if (newDocumentZos != null) {
						newDocumentZos.close();
					}
					if (newDocumentBaos != null) {
						newDocumentBaos.close();
					}
				} catch (IOException e) {
					throw e;
				}
			}
		}

	/**
		 * Parse model of styles.xml contained in model.otd, extract header
		 * insert extracted elements into document
		 * see: http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html for styles.xml format
		 * @param model dom doc of styles.xml of input model
		 * @param document dom doc of styles.xml of target document
		 * @return new styles.xml
		 * @throws PhiException
		 */
		public static byte[] replaceFirstPageHeader(Document model, Document document) throws PhiException {
	
			try {
	//			System.out.println("--------------------------------DOC BEFORE--------------------------------");
	//			System.out.println(nodeToString(document));
				
				//Replace style
				replaceNodeXpath(document, model, "office:styles", "//*[local-name()='style' and @*[local-name()='name' and .='Header']]", false);
				//replaceNodeXpath(document, model, "office:styles", "//style:style[@style:name=\"Header\"]");
				
				replaceNodeXpath(document, model, "office:styles", "//*[local-name()='style' and @*[local-name()='name' and .='Sub-Header']]", false);
				replaceNodeXpath(document, model, "office:styles", "//*[local-name()='style' and @*[local-name()='name' and .='Logo-Header']]", false);
				
				
				//replaceNodeXpath(document, model, "office:styles", "//*[local-name()='style' and @*[local-name()='name' and .='Footer']]");
				//replaceNodeXpath(document, model, "office:styles", "//style:style[@style:name=\"Footer\"]");
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='Header_Left_Cell']]", false);
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='Header_Right_Cell']]", false);
				
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='TabellaHeader']]", false);
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='TabellaHeader.A']]", false);
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='TabellaHeader.B']]", false);
				replaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style' and @*[local-name()='name' and .='TabellaHeader.C']]", false);
				//Replace header and footer
				replaceNode(document, model, "style:master-page", "style:header-first", false);
				//replaceNode(document, model, "style:master-page", "style:footer");
	
				
	//			System.out.println("--------------------------------DOC AFTER--------------------------------");
	//			System.out.println(nodeToString(document));
				
				return nodeToByteArray(document);
				
			} catch (Exception e) {
				throw new PhiException("Error replacing first page header ", e, ErrorConstants.APPLICATION_GENERIC_ERR_CODE);
	
			}
		}

	/**
	 * Parse model of styles.xml contained in model.otd, extract header and footer
	 * insert extracted elements into document
	 * see: http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html for styles.xml format
	 * @param model dom doc of styles.xml of input model
	 * @param document dom doc of styles.xml of target document
	 * @return new styles.xml
	 * @throws PhiException
	 */
	public static byte[] replaceHeaderFooter(Document model, Document document) throws PhiException {

		try {
		
//			//set office version to 1.3
//			Node documentOfficeDocumentStylesNode = document.getElementsByTagName(TAG_OFFICEDOCUMENTSTYLES).item(0);
//			NamedNodeMap documentOfficeStylesNodeAttributes = documentOfficeDocumentStylesNode.getAttributes();
//			Node officeVersionAttributeNode = documentOfficeStylesNodeAttributes.getNamedItem("office:version");
//			officeVersionAttributeNode.setNodeValue("1.3");
			
			//add or replace header style
			addOrReplaceNodeXpath(document, model, "office:automatic-styles", "//*[local-name()='style']", true);
			
			//Replace header and footer
			replaceNodeDirect(document, model, "office:master-styles");

			// merge other necessary sections
			mergeFonts(model, document);
			mergeOfficeDocumentStyles(model, document);
		
			return nodeToByteArray(document);
			
		} catch (Exception e) {
			throw new PhiException("Error replacing header and footer", e, ErrorConstants.APPLICATION_GENERIC_ERR_CODE);

		}
	}
	
	private static void replaceNodeDirect(Document document, Document model, String nodeName) throws PhiException {
		Node documentNode = document.getElementsByTagName(nodeName).item(0);
		Node modelNode = model.getElementsByTagName(nodeName).item(0);
		Node newDocumentNode = document.importNode(modelNode, true);
		Node parent = document.getElementsByTagName(documentNode.getParentNode().getNodeName()).item(0);
		replaceNode(document, parent, documentNode, newDocumentNode, true);
		
	}
	
	/**
	 * merges model's <office:font-face-decls> children into document
	 * 
	 * @param model
	 * @param document
	 * @throws PhiException
	 */
	private static void mergeFonts(Document model, Document document) throws PhiException {
		Node documentFontsFaceDecalsNode = document.getElementsByTagName(TAG_OFFICEFONTFACEDECLS).item(0);
		Node modelFontsFaceDecalsNode = model.getElementsByTagName(TAG_OFFICEFONTFACEDECLS).item(0);
		
		NodeList modelFonts = modelFontsFaceDecalsNode.getChildNodes();
		NodeList documentFonts = documentFontsFaceDecalsNode.getChildNodes();

		for(int i=0; i<modelFonts.getLength(); i++) {
			Node modelFont = modelFonts.item(i);
			if (modelFont == null || modelFont.getAttributes() == null) {
				continue;
			}
			Node modelStyleNameNode = modelFont.getAttributes().getNamedItem("style:name");
			Node fontAlreadyPresent = null;
			
			//look for the same font node in the document, if not found then append it
			for(int k=0; k<documentFonts.getLength(); k++) {
				Node documentFont = documentFonts.item(k);
				if (documentFont == null || documentFont.getAttributes() == null) {
					continue;
				}
				Node documentStyleNameNode = documentFont.getAttributes().getNamedItem("style:name");
				
				if(documentStyleNameNode.getNodeValue().equals(modelStyleNameNode.getNodeValue())) {
					// match is found
					fontAlreadyPresent = documentFont;
					break;
				}
			}
			
			if (fontAlreadyPresent == null) {
				Node newFontNode = document.importNode(modelFont, true);
				documentFontsFaceDecalsNode.appendChild(newFontNode);
			} else {
				Node newFontNode = document.importNode(modelFont, true);
				documentFontsFaceDecalsNode.replaceChild(newFontNode, fontAlreadyPresent);
			}
					
			
		}
	}
	
	/**
	 * merges model's <office:document-styles> attributes into document
	 * 
	 * @param model
	 * @param document
	 * @throws PhiException
	 */
	private static void mergeOfficeDocumentStyles(Document model, Document document) throws PhiException {
		Node documentOfficeDocumentStylesNode = document.getElementsByTagName(TAG_OFFICEDOCUMENTSTYLES).item(0);
		Node modelOfficeDocumentStylesNode = model.getElementsByTagName(TAG_OFFICEDOCUMENTSTYLES).item(0);
		
		NamedNodeMap modelDocumentStyles = modelOfficeDocumentStylesNode.getAttributes();
		NamedNodeMap documentDocumentStyles = documentOfficeDocumentStylesNode.getAttributes();
		
		for(int i = 0; i < modelDocumentStyles.getLength(); i++) {
			Node modelDocumentStyle = modelDocumentStyles.item(i);
			Node documentStyleAlreadyPresent = null;
			for(int k = 0; k < documentDocumentStyles.getLength(); k++) {
				Node documentDocumentStyle = documentDocumentStyles.item(k);
				if (documentDocumentStyle.getNodeName().equals(modelDocumentStyle.getNodeName())) {
					documentStyleAlreadyPresent = modelDocumentStyle;
					break;
				}
			}
			
			if (documentStyleAlreadyPresent == null) {
				((Element) documentOfficeDocumentStylesNode).setAttribute(modelDocumentStyle.getNodeName(), modelDocumentStyle.getNodeValue());
			}
			
		}
	}
	
	/**
	 * Replace oldChild with newChild
	 * @param doc
	 * @param parent
	 * @param oldChild
	 * @param newChild
	 */
	private static void replaceNode(Document document, Document model, String parentTagName, String tagName, boolean renameStyles) {
		Node documentNode = document.getElementsByTagName(tagName).item(0);
		Node modelNode = model.getElementsByTagName(tagName).item(0);
		Node newDocumentNode = document.importNode(modelNode, true);
		Node parent = document.getElementsByTagName(parentTagName).item(0);

		replaceNode(document, parent, documentNode, newDocumentNode, renameStyles);
	}
	
	//private static NamespaceContext context = new NamespaceC();( "style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0" );
	
	private static void replaceNodeXpath(Document document, Document model, String parentTagName, String xPath, boolean renameStyles) throws XPathExpressionException {
		XPathFactory xPathfactory = XPathFactory.newInstance();
		XPath xpath = xPathfactory.newXPath();
//		xpath.setNamespaceContext(context);
		XPathExpression expr = xpath.compile(xPath);
		
		Node documentNode = ((NodeList) expr.evaluate(document, XPathConstants.NODESET)).item(0);
		Node modelNode = ((NodeList) expr.evaluate(model, XPathConstants.NODESET)).item(0);
		if (modelNode == null) {
			return;
		}
		Node newDocumentNode = document.importNode(modelNode, true);
		Node parent = document.getElementsByTagName(parentTagName).item(0);

		replaceNode(document, parent, documentNode, newDocumentNode, renameStyles);
	}
	
	private static void addOrReplaceNodeXpath(Document document, Document model, String parentTagName, String xPath, boolean renameStyles) throws XPathExpressionException {
		XPathFactory xPathfactory = XPathFactory.newInstance();
		XPath xpath = xPathfactory.newXPath();
		XPathExpression expr = xpath.compile(xPath);
		
		NodeList templateStyleNodeList = ((NodeList) expr.evaluate(document, XPathConstants.NODESET));
		NodeList headerStyleNodeList = ((NodeList) expr.evaluate(model, XPathConstants.NODESET));
		
    	//scan all header styles for styles
		for (int h = 0; h < headerStyleNodeList.getLength(); h++) {
			Node headerStyleNode = headerStyleNodeList.item(h).cloneNode(true);
			if (headerStyleNode == null) {
				continue;
			}
	
			NamedNodeMap headerAttributeList = headerStyleNode.getAttributes();
			for (int k = 0; k < headerAttributeList.getLength(); k++) {

				Node headerStyleNodeAttribute = headerAttributeList.item(k);
				
				if (headerStyleNodeAttribute.getNodeName().equals("style:name")) {
					
    				//prepend the header prefix to style name if necessary
					if(!headerStyleNodeAttribute.getNodeValue().startsWith(headerPrefix)) {
						headerStyleNodeAttribute.setNodeValue(headerPrefix + headerStyleNodeAttribute.getNodeValue());
					}
					
					//prepend the header prefix to parent-style-name if necessary
					Node parentStyleNameAttribute = headerStyleNode.getAttributes().getNamedItem("style:parent-style-name");
					if(parentStyleNameAttribute != null && !parentStyleNameAttribute.getNodeValue().startsWith(headerPrefix)) {
						parentStyleNameAttribute.setNodeValue(headerPrefix + parentStyleNameAttribute.getNodeValue());
					}
					
					//prepend the header prefix to next-style-name if necessary
					Node parentNextStyleNameAttribute = headerStyleNode.getAttributes().getNamedItem("style:next-style-name");
					if(parentNextStyleNameAttribute != null && !parentNextStyleNameAttribute.getNodeValue().startsWith(headerPrefix)) {
						parentNextStyleNameAttribute.setNodeValue(headerPrefix + parentNextStyleNameAttribute.getNodeValue());
					}
					
					//scan all templates styles for a match
					Node templateMatch = null;
					for (int i = 0; i < templateStyleNodeList.getLength(); i++) {
						Node templateStyleNode = templateStyleNodeList.item(i);
						if (templateStyleNode == null) {
							continue;
						}
						NamedNodeMap attributeList = templateStyleNode.getAttributes();
						for (int a = 0; a < attributeList.getLength(); a++) {

							Node templateStyleNodeAttribute = attributeList.item(a);
							if (templateStyleNodeAttribute.getNodeName().equals("style:name")) {
								//check style name match
								if ((templateStyleNodeAttribute.getNodeValue()).equals(headerStyleNodeAttribute.getNodeValue())) {
									templateMatch = templateStyleNode;
									break;
								}
								
							}
						}
					}
					
					if (templateMatch != null) {
						// if an header style is already found among the template styles, replace it (keeping the prefix)
						Node newDocumentNode = document.importNode(headerStyleNode, true);
						templateMatch.getParentNode().replaceChild(newDocumentNode, templateMatch); // NPE as templateMatch has no parent
						
						
					} else {
						// if an header style is not found among the template styles, add it with a peculiar prefix
						Node templateParentNode = document.getElementsByTagName(parentTagName).item(0);
						Node newDocumentNode = document.importNode(headerStyleNode, true);
						templateParentNode.appendChild(newDocumentNode);
					}
					
					
				}
			}
		}
		
	}

	private static void replaceMultipleNodeXpath(Document document, Document model, String parentTagName, String xPath) throws XPathExpressionException {
		// NON USATO DA TESTARE
		XPathFactory xPathfactory = XPathFactory.newInstance();
		XPath xpath = xPathfactory.newXPath();
//		xpath.setNamespaceContext(context);
		XPathExpression expr = xpath.compile(xPath);

		NodeList documentNodeList = (NodeList) expr.evaluate(document, XPathConstants.NODESET);
		NodeList modelNodeList = (NodeList) expr.evaluate(model, XPathConstants.NODESET);
		
		for(int i=0; i<modelNodeList.getLength(); i++){
			Node documentNode = documentNodeList.item(i);

			Node modelNode = modelNodeList.item(i);
			if (modelNode == null) {
				return;
			}
			Node newDocumentNode = document.importNode(modelNode, true);
			Node parent = document.getElementsByTagName(parentTagName).item(i);

			replaceNode(document, parent, documentNode, newDocumentNode, false);
		}
	}
	
	private static void replaceNode(Document document, Node parent, Node oldChild, Node newChild, boolean renameStyles) {

		// prepend to each style-name the header prefix 
		if (renameStyles) {
			renameStyleNameAttribute(newChild);
		}
		newChild = document.importNode(newChild, true);
		if (oldChild != null) {
			parent.replaceChild(newChild, oldChild);
		} else {
			parent.appendChild(newChild);
		}
	}
	
	private static void renameStyleNameAttribute(Node node) {

		NamedNodeMap innerChildAttributeList = node.getAttributes();
		if (innerChildAttributeList != null) {
			for (int k = 0; k < innerChildAttributeList.getLength(); k++) {
				Node innerChildAttribute = innerChildAttributeList.item(k);
				if (innerChildAttribute.getNodeName().endsWith("style-name")) {
					if (!innerChildAttribute.getNodeValue().startsWith(headerPrefix)) {
						innerChildAttribute.setNodeValue(headerPrefix + innerChildAttribute.getNodeValue());
					}
				}
			}
		}
		
		NodeList innerChildNodes = node.getChildNodes();
		if (innerChildNodes != null) {
			for(int i = 0; i < innerChildNodes.getLength(); i++) {
				Node innerChild = innerChildNodes.item(i);
				renameStyleNameAttribute(innerChild);
			}
		}
	}
	
	/**
	 * Convert node to byteArray
	 * @param node to convert
	 * @return byte[]
	 */
	private static byte[] nodeToByteArray(Node node) throws TransformerException {
        Transformer transformer = TransformerFactory.newInstance().newTransformer();
        DOMSource source = new DOMSource(node);
    	ByteArrayOutputStream bos = new ByteArrayOutputStream();
    	transformer.transform(source, new StreamResult(bos));
    	return bos.toByteArray();
	}
	
	/**
	 * Convert node to string, used for debug only
	 * @param node to convert
	 * @return string
	 */
	@SuppressWarnings("unused")
	private static String nodeToString(Node node) throws TransformerException {
        Transformer transformer = TransformerFactory.newInstance().newTransformer();
        DOMSource source = new DOMSource(node);
        StringWriter writer = new StringWriter();
        transformer.transform(source, new StreamResult(writer));
        String output = writer.toString();
        return output.substring(output.indexOf("?>") + 2);//remove <?xml version="1.0" encoding="UTF-8"?>
	}
	
	public static void printNode(Node node) {
		try {
			TransformerFactory tf = TransformerFactory.newInstance();
		    Transformer transformer = tf.newTransformer();
		    transformer.setOutputProperty(OutputKeys.INDENT, "yes");
		    StringWriter writer = new StringWriter();
			transformer.transform(new DOMSource(node), new StreamResult(writer));
			System.out.println(writer.toString());
			//System.out.println(modelNode.getLocalName());
		} catch (TransformerException e) {
     		e.printStackTrace();
		}
		
	}
}


/**
 * Used to parse with DocumentBuilder.parse(new UncloseableInputStream(documentZis))
 * Since DocumentBuilder.parse closes the inputstream the zip inputstream cannot continue unzipping. 
 * see: http://stackoverflow.com/questions/20020982/java-create-inputstream-from-zipinputstream-entry
 */
class UncloseableInputStream extends InputStream {
	private final InputStream input;

	public UncloseableInputStream(InputStream input) {
		this.input = input;
	}

	@Override
	public void close() throws IOException {} // do not close the wrapped stream

	@Override
	public int read() throws IOException {
		return input.read();
	}
}